<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>获取Linux硬件信息编程 | Linux开发笔记</title>
  <meta name="author" content="lxl2015">
  
  <meta name="description" content="具体到相关函数和命令不做解释">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="获取Linux硬件信息编程"/>
  <meta property="og:site_name" content="Linux开发笔记"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="Linux开发笔记" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <!-- meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" /-->
  <!-- meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" /-->
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/avatar.gif">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">Linux开发笔记</a></h1>
		    <h2><a href="/"></a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/resume"><i class="fa fa-user"></i>关于我</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-07-30T06:25:34.000Z"><a href="/2017/07/30/获取Linux硬件信息编程/">2017-07-30</a></time>
        
  
    <h1 class="title">获取Linux硬件信息编程</h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%9A%E8%BF%87C%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="toc-text">一、通过C函数获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80"><span class="toc-text">1、获取IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96MAC%E5%9C%B0%E5%9D%80"><span class="toc-text">2、获取MAC地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96%E7%A1%AC%E7%9B%98%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-text">3、获取硬盘序列号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96CPU%E5%88%97%E5%8F%B7"><span class="toc-text">4、获取CPU列号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E8%BF%87Shell%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96"><span class="toc-text">5、通过Shell命令获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6"><span class="toc-text">二、分析系统文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-proc%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6"><span class="toc-text">1、&#x2F;proc目录下文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">2、使用的命令</span></a></li></ol></li></ol>
    </div>

        <p>具体到相关函数和命令不做解释</p>
<span id="more"></span>


<h2 id="一、通过C函数获取"><a href="#一、通过C函数获取" class="headerlink" title="一、通过C函数获取"></a>一、通过C函数获取</h2><h3 id="1、获取IP地址"><a href="#1、获取IP地址" class="headerlink" title="1、获取IP地址"></a>1、获取IP地址</h3><pre><code>/*************************************************************************
  &gt; File Name: test.c
  &gt; Author: 
  &gt; Mail: 
  &gt; Created Time: 2017年07月30日 星期日 15时08分31秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;netinet/in.h&gt; 
#include &lt;string.h&gt; 
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;net/if.h&gt;
#include &lt;linux/hdreg.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt; 

// 取得系统网卡当前的IP地址
int get_ip_addr(char *cache, int cache_len)
&#123;
    struct ifaddrs *ifAddrStruct=NULL;
    struct ifaddrs *ifa=NULL;
    void *tmpAddrPtr=NULL;
    char *tmp = cache;
    char addressBuffer[256];
    int ret = 0;


    memset(cache, 0, cache_len);


    if(getifaddrs(&amp;ifAddrStruct) &lt; 0)
    &#123;
        return -1;
    &#125;

    for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa-&gt;ifa_next) 
    &#123;
        if ((!ifa-&gt;ifa_addr) ||(strcmp(ifa-&gt;ifa_name,&quot;lo&quot;) == 0))
            continue;

        memset(addressBuffer, 0, 256);

        if (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET) 
        &#123; 
            tmpAddrPtr=&amp;((struct sockaddr_in *)ifa-&gt;ifa_addr)-&gt;sin_addr;
            inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);

            memcpy(tmp,addressBuffer,strlen(addressBuffer));

            tmp += strlen(addressBuffer) + 1;
            *(tmp - 1) = &#39;\n&#39;;

        &#125; 
        else if (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6) 
        &#123;
            tmpAddrPtr=&amp;((struct sockaddr_in6 *)ifa-&gt;ifa_addr)-&gt;sin6_addr;
            inet_ntop(AF_INET6, tmpAddrPtr, addressBuffer, INET6_ADDRSTRLEN);
            memcpy(tmp,addressBuffer,strlen(addressBuffer));
            tmp += strlen(addressBuffer) + 1;
            *(tmp - 1) = &#39;\n&#39;;
        &#125;
    &#125;
    if (ifAddrStruct!=NULL)
        freeifaddrs(ifAddrStruct);

    return 0;
&#125;


int main(int argc, const char *argv[])
&#123;
    char buffer[256];
    get_ip_addr(buffer,256);

    printf(&quot;IP:%s&quot;,buffer);
    return 0;
&#125;
</code></pre>
<h3 id="2、获取MAC地址"><a href="#2、获取MAC地址" class="headerlink" title="2、获取MAC地址"></a>2、获取MAC地址</h3><pre><code>/*************************************************************************
  &gt; File Name: test.c
  &gt; Author: 
  &gt; Mail: 
  &gt; Created Time: 2017年07月30日 星期日 15时08分31秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;netinet/in.h&gt; 
#include &lt;string.h&gt; 
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;net/if.h&gt;
#include &lt;linux/hdreg.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt; 

// 取得系统网卡当前的MAC地址
void get_mac_addr(char *cache, int cache_len)
&#123;
    int fd;
    struct ifreq ifr;
    struct ifaddrs *ifAddrStruct=NULL;
    struct ifaddrs *ifa=NULL;
    char buffer[256] = &#123;0&#125;;
    char *tmp = cache;
    int ret = 0;
    
    memset(cache,0,cache_len);


    getifaddrs(&amp;ifAddrStruct);

    for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa-&gt;ifa_next) 
    &#123;
        if ((!ifa-&gt;ifa_addr)||(strcmp(ifa-&gt;ifa_name,&quot;lo&quot;) == 0)|| \
                (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6) || \
                (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET))
            continue;

        fd = socket(AF_INET, SOCK_DGRAM, 0);

        ifr.ifr_addr.sa_family = AF_INET;
        strncpy(ifr.ifr_name, ifa-&gt;ifa_name, IFNAMSIZ-1);

        ioctl(fd, SIOCGIFHWADDR, &amp;ifr);

        close(fd);
        fd = -1;

        sprintf(buffer,&quot;%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;,
                (unsigned char)ifr.ifr_hwaddr.sa_data[0],
                (unsigned char)ifr.ifr_hwaddr.sa_data[1],
                (unsigned char)ifr.ifr_hwaddr.sa_data[2],
                (unsigned char)ifr.ifr_hwaddr.sa_data[3],
                (unsigned char)ifr.ifr_hwaddr.sa_data[4],
                (unsigned char)ifr.ifr_hwaddr.sa_data[5]);
        memcpy(tmp,buffer,strlen(buffer));
        tmp += strlen(buffer);
        memset(buffer,0,sizeof(buffer));
    &#125;

    if (ifAddrStruct!=NULL) 
        freeifaddrs(ifAddrStruct);

&#125;


int main(int argc, const char *argv[])
&#123;
    char buffer[256];
    get_mac_addr(buffer,256);

    printf(&quot;MAC:%s\n&quot;,buffer);
    return 0;
&#125;
</code></pre>
<h3 id="3、获取硬盘序列号"><a href="#3、获取硬盘序列号" class="headerlink" title="3、获取硬盘序列号"></a>3、获取硬盘序列号</h3><p>虚拟机下不能获取硬盘序列号</p>
<pre><code>/*************************************************************************
  &gt; File Name: test.c
  &gt; Author: 
  &gt; Mail: 
  &gt; Created Time: 2017年07月30日 星期日 15时08分31秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;netinet/in.h&gt; 
#include &lt;string.h&gt; 
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;net/if.h&gt;
#include &lt;linux/hdreg.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt; 

// 取得系统硬盘序列号
int get_hd_disk_num(char *cache, int cache_len)
&#123;
    int fd, i;
    FILE *fp;
    struct hd_driveid hid;
    char *tmp = cache;
    int ret = 0;
    char line[0x100], *disk, *root, *p;

    /*
     * 初始化相关参数
     * */
    memset(cache, 0, cache_len);

    
    if((fp = fopen(&quot;/etc/mtab&quot;, &quot;r&quot;)) == NULL)
    &#123;
        return -1;
    &#125;

    fd = -1;

    while(fgets(line, sizeof(line), fp) != NULL)
    &#123;
        disk = strtok(line, &quot; &quot;);

        if(disk ==  NULL)
            continue;

        root = strtok(NULL, &quot; &quot;);
        if(root == NULL)
            continue;

        if(strcmp(root, &quot;/&quot;) == 0)
        &#123;
            for(p = disk + strlen(disk) - 1; isdigit(*p); p --)
            
                *p = &#39;\0&#39;;
            
            fd = open(disk, O_RDONLY);
            if(fd &lt; 0)
                return -1;
            if(ioctl(fd, HDIO_GET_IDENTITY, &amp;hid) &lt; 0)
            &#123;
                if(errno == EBADF) 
                     return -1;
                else
                    return -1;
            &#125;
            close(fd);
            memcpy(tmp, hid.serial_no, strlen(hid.serial_no));
            tmp += strlen(hid.serial_no) + 1;
            *(tmp - 1) = &#39;\n&#39;;

        &#125;
    &#125;


    fclose(fp);
    return  0;
        
&#125;

int main(int argc, const char *argv[])
&#123;
    char buffer[256];
    get_hd_disk_num(buffer,256);

    printf(&quot;HD:%s&quot;,buffer);
    return 0;
&#125;
</code></pre>
<h3 id="4、获取CPU列号"><a href="#4、获取CPU列号" class="headerlink" title="4、获取CPU列号"></a>4、获取CPU列号</h3><p>根据dmicode源代码找到获取CPUID的方法</p>
<p>util.h</p>
<pre><code>//util.h
#include &lt;sys/types.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/if.h&gt;
#include &lt;string.h&gt;

#include &quot;types.h&quot;

struct dmi_header
&#123;
    u8 type;
    u8 length;
    u16 handle;
    u8 *data;
&#125;;

int checksum(const u8 *buf, size_t len);
void *mem_chunk(size_t base, size_t len, const char *devmem);
u64 u64_range(u64 start, u64 end);
void to_dmi_header(struct dmi_header *h, u8 *data);
int get_cpuid(char *cpuid);
</code></pre>
<p>types.h</p>
<pre><code>//types.h

#ifndef TYPES_H
#define TYPES_H


typedef unsigned char u8;
typedef unsigned short u16;
typedef signed short i16;
typedef unsigned int u32;

#ifdef BIGENDIAN
typedef struct &#123;
    u32 h;
    u32 l;
&#125; u64;
#else
typedef struct &#123;
    u32 l;
    u32 h;
&#125; u64;
#endif

#ifdef ALIGNMENT_WORKAROUND
static inline u64 U64(u32 low, u32 high)
&#123;
    u64 self;

    self.l = low;
    self.h = high;

    return self;
&#125;
#endif

#ifdef ALIGNMENT_WORKAROUND
#    ifdef BIGENDIAN
#    define WORD(x) (u16)((x)[1] + ((x)[0] &lt;&lt; 8))
#    define DWORD(x) (u32)((x)[3] + ((x)[2] &lt;&lt; 8) + ((x)[1] &lt;&lt; 16) + ((x)[0] &lt;&lt; 24))
#    define QWORD(x) (U64(DWORD(x + 4), DWORD(x)))
#    else /* BIGENDIAN */
#    define WORD(x) (u16)((x)[0] + ((x)[1] &lt;&lt; 8))
#    define DWORD(x) (u32)((x)[0] + ((x)[1] &lt;&lt; 8) + ((x)[2] &lt;&lt; 16) + ((x)[3] &lt;&lt; 24))
#    define QWORD(x) (U64(DWORD(x), DWORD(x + 4)))
#    endif /* BIGENDIAN */
#else /* ALIGNMENT_WORKAROUND */
#define WORD(x) (u16)(*(const u16 *)(x))
#define DWORD(x) (u32)(*(const u32 *)(x))
#define QWORD(x) (*(const u64 *)(x))
#endif /* ALIGNMENT_WORKAROUND */

#endif
</code></pre>
<p>util.c</p>
<pre><code>//util.c
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#ifdef USE_MMAP
#include &lt;sys/mman.h&gt;
#ifndef MAP_FAILED
#define MAP_FAILED ((void *) -1)
#endif /* !MAP_FAILED */
#endif /* USE MMAP */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

#include &quot;types.h&quot;
#include &quot;util.h&quot;

static int read_dev_mem(int fd, u8 *buf, size_t count, const char *prefix)
&#123;
    ssize_t r = 1;
    size_t r2 = 0;

    while (r2 != count &amp;&amp; r != 0)
    &#123;
        r = read(fd, buf + r2, count - r2);
        if (r == -1)
        &#123;
            if (errno != EINTR)
            &#123;
                close(fd);
                perror(prefix);
                return -1;
            &#125;
        &#125;
        else
            r2 += r;
    &#125;

    if (r2 != count)
    &#123;
        close(fd);
        fprintf(stderr, &quot;%s: Unexpected end of file\n&quot;, prefix);
        return -1;
    &#125;

    return 0;
&#125;

int checksum(const u8 *buf, size_t len)
&#123;
    u8 sum = 0;
    size_t a;

    for (a = 0; a &lt; len; a++)
        sum += buf[a];
    return (sum == 0);
&#125;

/*
 * Copy a physical memory chunk into a memory buffer.
 * This function allocates memory.
 */
void *mem_chunk(size_t base, size_t len, const char *devmem)
&#123;
    void *p;
    int fd;
#ifdef USE_MMAP
    size_t mmoffset;
    void *mmp;
#endif

    if ((fd = open(devmem, O_RDONLY)) == -1)
    &#123;
        perror(devmem);
        return NULL;
    &#125;

    if ((p = malloc(len)) == NULL)
    &#123;
        perror(&quot;malloc&quot;);
        return NULL;
    &#125;

#ifdef USE_MMAP
#ifdef _SC_PAGESIZE
    mmoffset = base % sysconf(_SC_PAGESIZE);
#else
    mmoffset = base % getpagesize();
#endif /* _SC_PAGESIZE */
    /*
     * Please note that we don&#39;t use mmap() for performance reasons here,
     * but to workaround problems many people encountered when trying
     * to read from /dev/mem using regular read() calls.
     */
    mmp = mmap(0, mmoffset + len, PROT_READ, MAP_SHARED, fd, base - mmoffset);
    if (mmp == MAP_FAILED)
        goto try_read;

    memcpy(p, (u8 *)mmp + mmoffset, len);

    if (munmap(mmp, mmoffset + len) == -1)
    &#123;
        fprintf(stderr, &quot;%s: &quot;, devmem);
        perror(&quot;munmap&quot;);
    &#125;

    goto out;

#endif /* USE_MMAP */

try_read:
    if (lseek(fd, base, SEEK_SET) == -1)
    &#123;
        fprintf(stderr, &quot;%s: &quot;, devmem);
        perror(&quot;lseek&quot;);
        free(p);
        return NULL;
    &#125;

    if (read_dev_mem(fd, p, len, devmem) == -1)
    &#123;
        free(p);
        return NULL;
    &#125;

out:
    if (close(fd) == -1)
        perror(devmem);

    return p;
&#125;

void to_dmi_header(struct dmi_header *h, u8 *data)
&#123;
    h-&gt;type = data[0];
    h-&gt;length = data[1];
    h-&gt;handle = WORD(data + 2);
    h-&gt;data = data;
&#125;

int get_cpuid(char *cpuid)
&#123;
    char devmem[10] = &quot;/dev/mem&quot;;
    u16 len;
    u16 num;
    size_t fp;
    u8 *buf=NULL, *nbuf=NULL, *data, *p;
    int i = 0;
    if ((buf = mem_chunk(0xF0000, 0x10000, devmem)) == NULL)
    &#123;
        free(buf);
        return 0;
    &#125;

    for (fp = 0; fp &lt;= 0xFFF0; fp += 16)
    &#123;
        if(memcmp(buf + fp, &quot;_SM_&quot;, 4) == 0 &amp;&amp; fp &lt;= 0xFFE0)
        &#123;
            len = WORD(buf + fp + 0x16);
            num = WORD(buf + fp + 0x1C);

            if (!checksum(buf + fp, (buf + fp)[0x05]) || memcmp(buf + fp + 0x10, &quot;_DMI_&quot;, 5) != 0 || !checksum(buf + fp + 0x10, 0x0F))
            &#123;
                free(buf);
                return 0;
            &#125;
            if ((nbuf = mem_chunk(DWORD(buf + fp + 0x18), len, devmem)) == NULL)
            &#123;
                fprintf(stderr, &quot;Table is unreachable, sorry.\n&quot;);
                free(buf);
                free(nbuf);
                return 0;
            &#125;
            data = nbuf;
            while (i &lt;=num &amp;&amp; data+4 &lt;= nbuf + len)
            &#123;
                u8 *next;
                struct dmi_header h;

                to_dmi_header(&amp;h, data);

                if (h.length &lt; 4)
                &#123;
                    printf(&quot;Invalid entry length (%u). DMI table is &quot;
                            &quot;broken! Stop.\n\n&quot;, (unsigned int)h.length);
                    free(buf);
                    free(nbuf);
                    return 0;
                &#125;

                next = data + h.length;
                while (next - nbuf + 1 &lt; len &amp;&amp; (next[0] != 0 || next[1] != 0))
                    next++;
                next += 2;
                if (h.type ==4)
                &#123;
                    p = h.data + 0x08;
                    sprintf(cpuid,&quot;%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n&quot;, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
                    cpuid +=24; 

                &#125;
                data = next;
                i++;
            &#125;
            fp += 16;
        &#125;
    &#125;
    free(buf);
    free(nbuf);
    return 0;
&#125;
</code></pre>
<p>main.c</p>
<pre><code>//main.c
#include &lt;stdio.h&gt;
#include &quot;util.h&quot;

int main()
&#123; 
    char cpuid[64] = &#123;0&#125;;
    get_cpuid(cpuid);
    fprintf(stdout,&quot;CPUID:\n%s&quot;, cpuid);
    return 0;
&#125;
</code></pre>
<p>里面定义的大端小端的，默认是小端</p>
<p>shell</p>
<pre><code># gcc util.c main.c -o main
# ./main
</code></pre>
<p>或者</p>
<pre><code># gcc util.c main.c  -D USE_MMAP -o main
# ./main
</code></pre>
<h3 id="5、通过Shell命令获取"><a href="#5、通过Shell命令获取" class="headerlink" title="5、通过Shell命令获取"></a>5、通过Shell命令获取</h3><p>通过出入Shell命令获取相关硬件信息.测试函数，别当真，写项目不要这样写。dmidecode需要root权限。</p>
<pre><code>/*************************************************************************
  &gt; File Name: test.c
  &gt; Author: 
  &gt; Mail: 
  &gt; Created Time: 2017年07月30日 星期日 15时08分31秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
int execute_cmd(char *cmd, char *info, int cache_len)
&#123;
    FILE *fp = NULL;
    int ret = 0;
    char buffer[256] = &#123;0&#125;;
    char *tmp = info;


    if(cmd == NULL)
        return -1;

    //dos2unix(cmd);

    if(NULL == (fp = popen(cmd,&quot;r&quot;)))
    &#123;
        return -1;
    &#125;

    while(NULL != fgets(buffer, 256,fp))
    &#123;

        memcpy(tmp, buffer, strlen(buffer));
        if(strlen(buffer) != 0)
        &#123;
            tmp += strlen(buffer) + 1;
            *(tmp - 1) = &#39;\n&#39;;
            memset(buffer, 0, sizeof(buffer));
        &#125;
    &#125;

    pclose(fp);

    return ret;
&#125;


// 取得系统默认网关IP地址
int get_gateway(char *cache, int  cache_len)
&#123;
    return execute_cmd(&quot;ip route 2&gt;/dev/null | grep default | awk &#39;&#123;print $3&#125;&#39;&quot;, cache, cache_len);
&#125;

// 取得系统主机名
int get_host_name(char *cache, int  cache_len)
&#123;
    return execute_cmd(&quot;hostname&quot;, cache, cache_len);
&#125;


// CPU ID  
int get_cpu_id(char *cache, int cache_len)
&#123;
    return execute_cmd(&quot;dmidecode -t 4 2&gt;/dev/null | grep ID |sort -u |awk -F&#39;: &#39; &#39;&#123;print $2&#125;&#39;&quot;, cache,\
            cache_len);
&#125;

// 主板序列号  
int get_board_ser(char *cache, int cache_len)
&#123;
    return execute_cmd(&quot;dmidecode -t 2 2&gt;/dev/null| grep &#39;Serial Number&#39;| awk -F : &#39;&#123;print $2&#125;&#39;&quot;,cache,\
            cache_len);
&#125;


// 主板型号  
int get_board_name(char *cache, int cache_len)
&#123;
    return execute_cmd(&quot;dmidecode -t 2 2&gt;/dev/null| grep &#39;Product Name&#39;| awk -F : &#39;&#123;print $2&#125;&#39;&quot;,\
            cache, cache_len);
&#125;

int main(int argc, const char *argv[])
&#123;
    char buffer[256];
    memset(buffer, 0, 256);
    get_gateway(buffer,256);
    printf(&quot;gateway:%s&quot;,buffer);


    memset(buffer, 0, 256);
    get_host_name(buffer,256);
    printf(&quot;hostname:%s&quot;,buffer);



    memset(buffer, 0, 256);
    get_cpu_id(buffer,256);
    printf(&quot;cpiid:%s&quot;,buffer);


    memset(buffer, 0, 256);
    get_board_ser(buffer,256);
    printf(&quot;board_ser:%s&quot;,buffer);


    memset(buffer, 0, 256);
    get_board_name(buffer,256);
    printf(&quot;boar_name:%s&quot;,buffer);



    return 0;
&#125;
</code></pre>
<p>获取硬件的属性，主要就是下面的两种方法，第一种就是读取/proc目录下的文件，进行分析，另外一种就是通过命令获取。</p>
<h2 id="二、分析系统文件"><a href="#二、分析系统文件" class="headerlink" title="二、分析系统文件"></a>二、分析系统文件</h2><h3 id="1、-proc目录下文件"><a href="#1、-proc目录下文件" class="headerlink" title="1、/proc目录下文件"></a>1、/proc目录下文件</h3><p>详细的信息请使用 <code>man proc</code></p>
<pre><code># cat /proc/cpuinfo                查看CPU相关参数
# cat /proc/meminfo                查看linux系统内存信息
# cat /proc/partitions            查看linux硬盘和分区信息的系统信息
# cat /proc/ioports                查看设备io端口
# cat /proc/interrupts            查看中断
# cat /proc/pci                    查看pci设备的信息
# cat /proc/swaps                查看所有swap分区的信息
# cat /proc/devices                可用设备列表
# cat /proc/mounts                已加载的文件系统列表 
# cat /proc/bus/usb/devices        查看USB设备
# cat /proc/bus/input/devices    查看键盘和鼠标
</code></pre>
<h3 id="2、使用的命令"><a href="#2、使用的命令" class="headerlink" title="2、使用的命令"></a>2、使用的命令</h3><pre><code># yum install lshw
# lshw 
</code></pre>
<p>一个提供关于本机硬件配置的详细信息的小工具。它可以确切报告内存配置、 固件版本、主板配置、CPU 版本和速度、缓存配置和总线速度等信息。<br>详细的内容 <code>man lshw</code></p>
<pre><code># yum install lsscsi
</code></pre>
<p>lsscsi 列出SCSI设备(或主机)及其属性。<br>详细的内容 <code>man lsscsi</code></p>
<pre><code># lscpu
</code></pre>
<p>　　此命令用来显示cpu的相关信息<br>　　lscpu从sysfs和/proc/cpuinfo收集cpu体系结构信息，命令的输出比较易读<br>　　命令输出的信息包含cpu数量，线程，核数，套接字和Nom-Uniform Memeor Access(NUMA)，缓存等<br>　　不是所有的列都支持所有的架构，如果指定了不支持的列，那么lscpu将打印列，但不显示数据 </p>
<pre><code># lsusb 
</code></pre>
<p>来列出 USB 设备和它的属性，lsusb 会显示驱动和内部连接到你系统的设备。</p>
<pre><code># lsblk
</code></pre>
<p>lsblk命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。</p>
<pre><code># lspci
</code></pre>
<p>lspci，顾名思义，就是显示所有的pci设备信息</p>
<p>Dmidecode 这获取有关硬件方面的信息。Dmidecode 遵循 SMBIOS/DMI 标准，其输出的信息包括 BIOS、系统、主板、处理器、内存、缓存等等。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/07-Linux-Dev/">07. Linux Dev</a>
  </div>

        
  <div class="tags">
    <a href="/tags/Linux/">Linux</a>, <a href="/tags/C/">C</a>, <a href="/tags/dmidecode/">dmidecode</a>
  </div>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
<section id = "relate">
	
</section>




</div></div>
      <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/01-CPP-%E5%9F%BA%E7%A1%80/">01. CPP 基础</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/02-C%E5%9F%BA%E7%A1%80/">02. C基础</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/03-Python/">03.Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/04-Algorithm/">04. Algorithm</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/05-Linux-Operation/">05. Linux Operation</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/06-Compile-Tools/">06. Compile Tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/07-Linux-Dev/">07. Linux Dev</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/08-DataBase/">08. DataBase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/08-Database/">08. Database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/08-DataBase/">08.DataBase</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/09-Windows-System/">09. Windows System</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/10-Web/">10. Web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/11-Open-Source/">11. Open Source</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/11-Open-Source/">11.Open Source</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/12-Other/">12. Other</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/12-Other/">12.Other</a><span class="category-list-count">1</span></li></ul> 
</div>
 


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">公元 2020 年</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">公元 2019 年</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">公元 2018 年</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">66</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">公元 2016 年</a><span class="archive-list-count">1</span></li></ul>
  </div>

</aside>
      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2021 lxl2015
    
  </div>

  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->




<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>


<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
